<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Storm Calculator + Geostrophic Wind</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 2rem;
      background-color: #f0f8ff;
      line-height: 1.6;
    }
    .container {
      background: #fff;
      padding: 2rem;
      border-radius: 10px;
      max-width: 900px;
      margin: auto;
      box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
    }
    h1, h2, h3 {
      text-align: center;
      color: #333;
    }
    label {
      display: block;
      margin-top: 1.2rem;
      color: #333;
    }
    input[type="number"] {
      width: 100%;
      padding: 0.5rem;
      margin-top: 0.3rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-family: monospace;
      padding: 0.5rem;
      margin-top: 0.3rem;
    }
    .unknown-option {
      font-size: 0.9rem;
      margin-top: 0.3rem;
    }
    button {
      display: block;
      width: 100%;
      padding: 0.8rem;
      background: #007acc;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 1.5rem;
      transition: background 0.3s;
    }
    button:hover {
      background: #005fa3;
    }
    .result {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #e9f5ff;
      border: 1px solid #b3d7ff;
      border-radius: 8px;
    }
    .formula {
      background: #eef;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      display: inline-block;
      margin: 0.2rem 0;
    }
    .info, .geo-info {
      background: #fff8dc;
      padding: 1rem;
      border: 1px solid #f4e1a1;
      border-radius: 8px;
      margin-top: 1.5rem;
    }
    .sub-section {
      background: #fffceb;
      border: 1px solid #ffe9b9;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Storm Calculator</h1>
    <h2>Including Geostrophic Wind & Divergence</h2>

    <div class="info">
      <p><strong>Instructions:</strong> Enter <em>exactly two</em> of the three primary inputs (CAPE, Bulk Wind Shear in knots, and Storm Tilt Angle in degrees). Optionally, enter lightning strikes per minute. For any parameter you don’t know, check its “Unknown” box. This calculator then computes the missing parameter, effective updraft speed, and total shear.</p>
      <p>This version also includes a simple geostrophic wind calculation, based on a provided 2D pressure field, to demonstrate how larger-scale wind fields could impact local shear and vertical velocity.</p>
    </div>

    <!-- Primary Inputs -->
    <label for="cape">CAPE (J/kg):</label>
    <input type="number" id="cape" placeholder="e.g. 2000" step="any" />
    <label class="unknown-option"><input type="checkbox" id="capeUnknown"> Unknown</label>

    <label for="shear">Bulk Wind Shear (knots):</label>
    <input type="number" id="shear" placeholder="e.g. 30" step="any" />
    <label class="unknown-option"><input type="checkbox" id="shearUnknown"> Unknown</label>

    <label for="angle">Storm Tilt Angle (θ in degrees):</label>
    <input type="number" id="angle" placeholder="e.g. 25" step="any" />
    <label class="unknown-option"><input type="checkbox" id="angleUnknown"> Unknown</label>

    <label for="strikes">Lightning Strikes per Minute:</label>
    <input type="number" id="strikes" placeholder="e.g. 50" step="1" />

    <!-- Optional Geographic Data -->
    <div class="geo-info">
      <h3>Geographic Data (Optional)</h3>
      <label for="stormLat">Storm Latitude (°):</label>
      <input type="number" id="stormLat" placeholder="e.g. 40.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLatUnknown"> Unknown</label>

      <label for="stormLon">Storm Longitude (°):</label>
      <input type="number" id="stormLon" placeholder="e.g. -80.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLonUnknown"> Unknown</label>

      <label for="observerLat">Observer Latitude (°):</label>
      <input type="number" id="observerLat" placeholder="e.g. 38.5" step="any" />
      <label class="unknown-option"><input type="checkbox" id="observerLatUnknown"> Unknown</label>

      <label for="observerLon">Observer Longitude (°):</label>
      <input type="number" id="observerLon" placeholder="e.g. -77.0" step="any" />

      <label for="elevAngle">Elevation Angle from Observer (°):</label>
      <input type="number" id="elevAngle" placeholder="e.g. 10" step="any" />
      <label class="unknown-option"><input type="checkbox" id="elevAngleUnknown"> Unknown</label>
    </div>

    <!-- Additional Section: Geostrophic Wind Inputs -->
    <div class="sub-section">
      <h3>Geostrophic Wind & Divergence (Optional)</h3>
      <p>Provide a 2D pressure field (Pa) for a simple demonstration of geostrophic wind and divergence-based vertical velocity. In real life, you would retrieve this from your model outputs or observational grids.</p>

      <!-- Grid spacing -->
      <label for="gridX">Grid Spacing in X (m):</label>
      <input type="number" id="gridX" placeholder="e.g. 10000" step="any" />
      <label for="gridY">Grid Spacing in Y (m):</label>
      <input type="number" id="gridY" placeholder="e.g. 10000" step="any" />

      <label for="pressureData">
        Enter Pressure Field as rows of comma-separated values (Pa).<br>
        Example (3x3):
        <br>100000, 100010, 100020<br>
        99990, 100000, 100010<br>
        99980, 99990, 100000
      </label>
      <textarea id="pressureData" placeholder="Paste your pressure data grid here..."></textarea>

      <label for="pressureDp">Pressure Difference (dp in Pa) between levels:</label>
      <input type="number" id="pressureDp" placeholder="e.g. 50" step="any" />

      <!-- Output placeholders for geostrophic wind and vertical velocity -->
      <div id="geoResults" class="result" style="display:none;">
        <h4>Geostrophic Wind Results</h4>
        <p>
          <strong>Average Geostrophic U (m/s):</strong> <span id="geoU"></span><br>
          <strong>Average Geostrophic V (m/s):</strong> <span id="geoV"></span><br>
          <strong>Average Horizontal Divergence (1/s):</strong> <span id="divVal"></span><br>
          <strong>Estimated Vertical Velocity (omega, Pa/s):</strong> <span id="omegaVal"></span>
        </p>
      </div>
    </div>

    <button id="calcButton">Calculate</button>

    <!-- Results -->
    <div id="result" class="result" style="display:none;">
      <h3>Storm Results</h3>
      <p>
        <strong>CAPE:</strong> <span id="capeVal"></span> J/kg<br>
        <strong>Shear (basic or computed):</strong> <span id="shearVal"></span> knots<br>
        <strong>Angle (θ):</strong> <span id="angleVal"></span> °<br>
        <strong>Effective Updraft Speed (w):</strong> <span id="updraft_mps"></span><br>
        <strong>Total Effective Shear:</strong> <span id="totalShear"></span> knots<br>
        <strong>Storm Height:</strong> <span id="heightVal"></span><br>
        <strong>Rotational Shear Contribution:</strong> <span id="rotationShear"></span>
      </p>
      <p id="explanation"></p>
    </div>
  </div>

  <script>
    /************************************************************
     * Constants & Helper Functions
     ************************************************************/
    const mpsToKnots = 1.94384;
    const mpsToKmph = 3.6;
    const dragCoefficient = 0.8;
    const dragScalingConstant = 1e6;
    const seaLevelAirDensity = 1.225;
    const T0 = 288.15;
    const L = 0.0065;
    const g = 9.80665;
    const R = 287.058;
    const Omega = 7.2921e-5; // Earth's rotation rate in rad/s

    // For lightning scaling (γ parameter)
    const lightningGamma = 0.5; // Adjust sensitivity of lightning effect

    // For geostrophic calculations
    const fConstant = 1e-4; // typical mid-lat Coriolis parameter (s^-1), if not computed from lat

    function degToRad(deg) {
      return deg * (Math.PI / 180);
    }
    function radToDeg(rad) {
      return rad * (180 / Math.PI);
    }
    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    // Compute air density at a given height (in meters)
    function calculateAirDensity(height) {
      const T = T0 - L * height;
      if (T <= 0) return 0;
      const exponent = (g / (R * L)) - 1;
      return seaLevelAirDensity * Math.pow((T / T0), exponent);
    }

    // Default storm height using CAPE (if geo not provided)
    function defaultStormHeight(cape) {
      return 4000 + 2 * Math.sqrt(cape);
    }

    // Haversine formula to get horizontal distance in meters
    function haversine(lat1, lon1, lat2, lon2) {
      const R_earth = 6371000; // radius in meters
      let dLat = degToRad(lat2 - lat1);
      let dLon = degToRad(lon2 - lon1);
      let a = Math.sin(dLat/2) ** 2 +
              Math.cos(degToRad(lat1)) * Math.cos(degToRad(lat2)) *
              Math.sin(dLon/2) ** 2;
      let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R_earth * c;
    }

    // Effective updraft from CAPE + lightning + drag
    function computeEffectiveUpdraft(cape, strikes, stormHeight) {
      let wIdeal = Math.sqrt(2 * cape);
      let airDensity = calculateAirDensity(stormHeight);
      let dragFactor = 1 - (dragCoefficient * airDensity * stormHeight / dragScalingConstant);
      dragFactor = Math.max(0, dragFactor);
      let lightningFactor = 1 + lightningGamma * (strikes / 100);
      let wEff = wIdeal * dragFactor * lightningFactor;
      return { wEff, dragFactor };
    }

    /************************************************************
     * Geostrophic Wind + Divergence (Adapted from Python snippet)
     ************************************************************/
    // We'll treat "pressure" as a 2D array: pressure[row][col].
    // Inputs: pressure field 2D array, dx, dy (m).
    function geostrophicWind(pressure, dx, dy, coriolisParam) {
      // Returns u_g, v_g as 2D arrays
      //   u_g = -1/f * dP/dy
      //   v_g =  1/f * dP/dx
      // We'll do a simple finite-difference approach for gradient.

      const nx = pressure.length;
      const ny = (nx > 0) ? pressure[0].length : 0;

      let u_g = Array.from({length: nx}, () => Array(ny).fill(0));
      let v_g = Array.from({length: nx}, () => Array(ny).fill(0));

      // Gradient in the x-direction (columns)
      // For v_g, we need dP/dx
      // For simplicity, partial differences:
      for (let i = 0; i < nx; i++) {
        for (let j = 0; j < ny-1; j++) {
          let dPdx = (pressure[i][j+1] - pressure[i][j]) / dx; // forward difference
          v_g[i][j] = (1 / coriolisParam) * dPdx;
        }
        // last column can approximate or set to same as previous
        v_g[i][ny-1] = v_g[i][ny-2];
      }

      // Gradient in the y-direction (rows)
      // For u_g, we need dP/dy
      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx-1; i++) {
          let dPdy = (pressure[i+1][j] - pressure[i][j]) / dy;
          // note the negative sign
          u_g[i][j] = -(1 / coriolisParam) * dPdy;
        }
        // last row approximate:
        u_g[nx-1][j] = u_g[nx-2][j];
      }

      return {u_g, v_g};
    }

    // Horizontal divergence
    function horizontalDivergence(u, v, dx, dy) {
      const nx = u.length;
      const ny = (nx > 0) ? u[0].length : 0;
      let div = Array.from({length: nx}, () => Array(ny).fill(0));
      // Forward difference for simplicity
      for (let i = 0; i < nx-1; i++) {
        for (let j = 0; j < ny-1; j++) {
          let dudx = (u[i][j+1] - u[i][j]) / dx;
          let dvdy = (v[i+1][j] - v[i][j]) / dy;
          div[i][j] = dudx + dvdy;
        }
      }
      // edges can be approximated or left as 0
      return div;
    }

    // Vertical velocity (omega) from divergence
    //   omega = - divergence * dp
    // If divergence is in 1/s, dp in Pa, result is Pa/s
    function verticalVelocity(divergence, dp) {
      const nx = divergence.length;
      const ny = (nx > 0) ? divergence[0].length : 0;
      let omega = Array.from({length: nx}, () => Array(ny).fill(0));
      for (let i = 0; i < nx; i++) {
        for (let j = 0; j < ny; j++) {
          omega[i][j] = -divergence[i][j] * dp;
        }
      }
      return omega;
    }

    /************************************************************
     * Main Calculation Logic
     ************************************************************/
    document.getElementById("calcButton").addEventListener("click", function () {
      //=== 1) Primary Storm Calculator Inputs ===
      let capeStr = document.getElementById("cape").value.trim();
      let shearStr = document.getElementById("shear").value.trim();
      let angleStr = document.getElementById("angle").value.trim();
      let strikesStr = document.getElementById("strikes").value.trim();

      let capeUnknown = document.getElementById("capeUnknown").checked;
      let shearUnknown = document.getElementById("shearUnknown").checked;
      let angleUnknown = document.getElementById("angleUnknown").checked;

      let providedCAPE = (!capeUnknown && capeStr !== "") ? parseFloat(capeStr) : undefined;
      let providedShear = (!shearUnknown && shearStr !== "") ? parseFloat(shearStr) : undefined;
      let providedAngle = (!angleUnknown && angleStr !== "") ? parseFloat(angleStr) : undefined;

      // Must have exactly 2 known among (CAPE, Shear, Angle)
      let count = 0;
      if (providedCAPE !== undefined) count++;
      if (providedShear !== undefined) count++;
      if (providedAngle !== undefined) count++;
      if (count !== 2) {
        alert("Please ensure exactly two of the three (CAPE, Shear, Angle) are provided.");
        return;
      }

      // Lightning
      let strikes = (strikesStr !== "") ? parseInt(strikesStr) : 50;
      if (strikes < 0) {
        alert("Lightning strikes per minute must be non-negative.");
        return;
      }

      //=== 2) Geographic Data (Optional) ===
      let stormLatStr = document.getElementById("stormLat").value.trim();
      let stormLonStr = document.getElementById("stormLon").value.trim();
      let observerLatStr = document.getElementById("observerLat").value.trim();
      let observerLonStr = document.getElementById("observerLon").value.trim();
      let elevAngleStr = document.getElementById("elevAngle").value.trim();

      let stormLatUnknown = document.getElementById("stormLatUnknown").checked;
      let stormLonUnknown = document.getElementById("stormLonUnknown").checked;
      let observerLatUnknown = document.getElementById("observerLatUnknown").checked;
      let elevAngleUnknown = document.getElementById("elevAngleUnknown").checked;

      // Horizontal distance if lat/lon provided
      let horizontalDistance = undefined;
      if (!stormLatUnknown && !stormLonUnknown && !observerLatUnknown &&
          stormLatStr !== "" && stormLonStr !== "" && observerLatStr !== "") {
        let stormLat = parseFloat(stormLatStr);
        let stormLon = parseFloat(stormLonStr);
        let observerLat = parseFloat(observerLatStr);
        let observerLon = (observerLonStr !== "") ? parseFloat(observerLonStr) : 0;
        horizontalDistance = haversine(observerLat, observerLon, stormLat, stormLon);
      }

      // Compute storm height from geo data if possible
      let geoHeightComputed = false;
      let finalStormHeight;
      if (!elevAngleUnknown && elevAngleStr !== "" && horizontalDistance !== undefined) {
        let elevAngle = parseFloat(elevAngleStr);
        finalStormHeight = horizontalDistance * Math.tan(degToRad(elevAngle));
        geoHeightComputed = true;
      } else if (providedCAPE !== undefined) {
        finalStormHeight = defaultStormHeight(providedCAPE);
      } else {
        finalStormHeight = 4000; // fallback
      }

      //=== 3) Solve for the missing parameter (CAPE, Shear, or Angle) ===
      let computedCAPE = providedCAPE;
      let computedShear = providedShear;
      let computedAngle = providedAngle; // degrees

      // (a) Missing Angle
      if (providedAngle === undefined) {
        if (providedCAPE === undefined) {
          alert("Cannot compute angle without CAPE for updraft calculation.");
          return;
        }
        let { wEff } = computeEffectiveUpdraft(providedCAPE, strikes, finalStormHeight);
        if (!wEff) {
          alert("Effective updraft is zero; cannot solve for angle.");
          return;
        }
        let shear_ms = providedShear / mpsToKnots; // convert to m/s
        computedAngle = radToDeg(Math.atan(shear_ms / wEff));
      }
      // (b) Missing Shear
      else if (providedShear === undefined) {
        if (providedCAPE === undefined) {
          alert("Cannot compute shear without CAPE for updraft.");
          return;
        }
        let { wEff } = computeEffectiveUpdraft(providedCAPE, strikes, finalStormHeight);
        let angleRad = degToRad(providedAngle);
        let shear_ms = wEff * Math.tan(angleRad);
        computedShear = shear_ms * mpsToKnots;
      }
      // (c) Missing CAPE
      else if (providedCAPE === undefined) {
        // Invert w = sqrt(2*CAPE)*D*(1 + gamma*(strikes/100))
        // and U_basic = w * tan(angle)
        // => CAPE = [ (U_basic / tan(angle)) / (D*(1 + ...)) ]^2 / 2
        let defaultHeight = 4000; // fallback
        let airDensityDefault = calculateAirDensity(defaultHeight);
        let dragFactorDefault = 1 - (dragCoefficient * airDensityDefault * defaultHeight / dragScalingConstant);
        dragFactorDefault = Math.max(0, dragFactorDefault);
        let lightningFactor = 1 + lightningGamma*(strikes/100);
        let angleRad = degToRad(providedAngle);
        let shear_ms = providedShear / mpsToKnots;
        let wBasic = shear_ms / Math.tan(angleRad);
        let sqrtTerm = wBasic / (dragFactorDefault*lightningFactor);
        computedCAPE = (Math.pow(sqrtTerm, 2))/2;
      }

      // Compute final updraft speed
      let finalUpdraft = 0;
      if (computedCAPE !== undefined) {
        let updraftData = computeEffectiveUpdraft(computedCAPE, strikes, finalStormHeight);
        finalUpdraft = updraftData.wEff;
      }

      // Basic shear from finalUpdraft & angle
      let angleRadFinal = degToRad(computedAngle);
      let basicShear_ms = finalUpdraft * Math.tan(angleRadFinal);
      let basicShear_knots = basicShear_ms * mpsToKnots;

      // Geolocation correction for rotation
      let rotationalShear_ms = 0;
      if (horizontalDistance !== undefined && !observerLatUnknown && observerLatStr !== "") {
        let observerLatVal = parseFloat(observerLatStr);
        let fVal = 2 * Omega * Math.sin(degToRad(observerLatVal));
        rotationalShear_ms = fVal * horizontalDistance;
      }
      let rotationalShear_knots = rotationalShear_ms * mpsToKnots;
      let totalShear_knots = basicShear_knots + rotationalShear_knots;

      //=== 4) Geostrophic Wind & Divergence (if user inputs a 2D pressure field) ===
      let dxStr = document.getElementById("gridX").value.trim();
      let dyStr = document.getElementById("gridY").value.trim();
      let pressureRaw = document.getElementById("pressureData").value.trim();
      let dpStr = document.getElementById("pressureDp").value.trim();

      if (dxStr !== "" && dyStr !== "" && pressureRaw !== "" && dpStr !== "") {
        let dxVal = parseFloat(dxStr);
        let dyVal = parseFloat(dyStr);
        let dpVal = parseFloat(dpStr);

        // Convert pressureRaw into a 2D array
        // Each line => row, comma-separated => columns
        let lines = pressureRaw.split("\n");
        let pressure2D = lines.map(line => {
          let cols = line.split(",").map(v => parseFloat(v.trim()));
          return cols;
        });

        let geo = geostrophicWind(pressure2D, dxVal, dyVal, fConstant);
        let div2D = horizontalDivergence(geo.u_g, geo.v_g, dxVal, dyVal);
        let omega2D = verticalVelocity(div2D, dpVal);

        // Compute average
        const nx = pressure2D.length;
        const ny = (nx>0)? pressure2D[0].length:0;
        let sumU=0, sumV=0, sumDiv=0, sumOmega=0;
        let count = 0;
        for (let i=0; i<nx; i++){
          for (let j=0; j<ny; j++){
            sumU += geo.u_g[i][j];
            sumV += geo.v_g[i][j];
            sumDiv += div2D[i][j];
            sumOmega += omega2D[i][j];
            count++;
          }
        }
        let avgU = sumU / count;
        let avgV = sumV / count;
        let avgDiv = sumDiv / count;
        let avgOmega = sumOmega / count;

        document.getElementById("geoU").textContent = round(avgU, 3);
        document.getElementById("geoV").textContent = round(avgV, 3);
        document.getElementById("divVal").textContent = round(avgDiv, 5);
        document.getElementById("omegaVal").textContent = round(avgOmega, 5);

        document.getElementById("geoResults").style.display = "block";
      } else {
        document.getElementById("geoResults").style.display = "none";
      }

      //=== 5) Display Storm Calculator Results ===
      document.getElementById("capeVal").textContent = (computedCAPE !== undefined) ? round(computedCAPE, 2) : "N/A";
      document.getElementById("shearVal").textContent = (computedShear !== undefined) ? round(computedShear, 2) : round(basicShear_knots, 2);
      document.getElementById("angleVal").textContent = (computedAngle !== undefined) ? round(computedAngle, 2) : "N/A";
      document.getElementById("updraft_mps").textContent = round(finalUpdraft, 2) + " m/s (" + round(finalUpdraft*mpsToKnots, 2) + " knots)";
      document.getElementById("totalShear").textContent = round(totalShear_knots, 2);
      document.getElementById("heightVal").textContent = round(finalStormHeight, 2) + (geoHeightComputed ? " m (geo-trig)" : " m");
      if (rotationalShear_knots !== 0) {
        document.getElementById("rotationShear").textContent = round(rotationalShear_knots, 2) + " knots (rotational)";
      } else {
        document.getElementById("rotationShear").textContent = "Not computed (insufficient geo data)";
      }

      // Explanation
      let explanationText =
        "<strong>Equations & Process:</strong><br>" +
        "<ul>" +
        "<li><span class='formula'>w = √(2×CAPE) × D × (1 + γ×(strikes/100))</span>, where <em>D</em> is the drag factor and γ=" + lightningGamma + ".</li>" +
        "<li><span class='formula'>D = 1 - (C<sub>d</sub> × ρ × H / dragScalingConstant)</span>.</li>" +
        "<li>We solve for the missing one among <em>CAPE</em>, <em>Shear</em>, or <em>Angle</em> via <span class='formula'>U = w × tan(θ)</span>.</li>" +
        "<li>Total shear adds a rotational term <span class='formula'>2Ω sin(lat) × distance</span> if geolocation data are provided.</li>" +
        "<li>Geostrophic wind from pressure gradient: <span class='formula'>u<sub>g</sub> = -1/f ∂p/∂y</span>, <span class='formula'>v<sub>g</sub> = 1/f ∂p/∂x</span>.</li>" +
        "<li>Horizontal divergence: <span class='formula'>∇ · V = ∂u/∂x + ∂v/∂y</span>.</li>" +
        "<li>Vertical velocity (omega): <span class='formula'>ω = -(∇ · V) × Δp</span>.</li>" +
        "</ul>" +
        "Field data might come from radiosondes (for CAPE, shear), radar/lidar wind profiles (for observed shear & tilt), and model/analysis grids (for pressure fields).";
      document.getElementById("explanation").innerHTML = explanationText;

      document.getElementById("result").style.display = "block";
    });
  </script>
</body>
</html>
