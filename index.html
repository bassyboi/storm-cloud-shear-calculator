<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>All-in-One Storm Survey Calculator (with PDF & Date-Named)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f2f8ff;
    }
    .container {
      max-width: 900px;
      margin: auto;
      background: #fff;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
    }
    h1, h2 {
      text-align: center;
      color: #333;
      margin-bottom: 1rem;
    }
    label {
      display: block;
      margin-top: 1.2rem;
      font-weight: 600;
    }
    input[type="number"] {
      display: block;
      width: 100%;
      padding: 0.5rem;
      font-size: 1rem;
      margin-top: 0.3rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .unknown-option {
      font-size: 0.9rem;
      margin-top: 0.3rem;
    }
    button {
      width: 100%;
      font-size: 1rem;
      padding: 0.8rem;
      margin-top: 1.2rem;
      border: none;
      border-radius: 4px;
      background: #007acc;
      color: #fff;
      cursor: pointer;
    }
    button:hover {
      background: #005fa3;
    }
    .result {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #e9f5ff;
      border: 1px solid #b3d7ff;
      border-radius: 8px;
    }
    .formula {
      background: #eef;
      padding: 2px 5px;
      border-radius: 4px;
      font-family: monospace;
      display: inline-block;
      margin: 0.2rem 0;
    }
    .info-block {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #fff8dc;
      border: 1px solid #f4e1a1;
      border-radius: 8px;
    }
    .subtle {
      color: #555;
      font-size: 0.9rem;
    }
    .inline-value {
      font-weight: 600;
      color: #006;
    }
    .two-buttons {
      display: flex;
      gap: 0.5rem;
    }
    .two-buttons button {
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Storm Survey Calculator</h1>
    <h2>All-in-One (CAPE, Shear, Angle, Geometry, PDF Output)</h2>

    <p class="subtle">
      Enter <em>exactly two</em> of CAPE, Bulk Shear (knots), or Storm Tilt Angle (°). The calculator finds the missing one.
      Provide lat/lon and an elevation angle if you'd like a geometric storm height. Include lightning strikes
      (per minute) to factor into updraft. 
    </p>

    <!-- Primary Inputs -->
    <label for="cape">CAPE (J/kg):</label>
    <input type="number" id="cape" placeholder="e.g. 2000" step="any" />
    <label class="unknown-option"><input type="checkbox" id="capeUnknown"> Unknown</label>

    <label for="shear">Bulk Wind Shear (knots):</label>
    <input type="number" id="shear" placeholder="e.g. 30" step="any" />
    <label class="unknown-option"><input type="checkbox" id="shearUnknown"> Unknown</label>

    <label for="angle">Storm Tilt Angle (°):</label>
    <input type="number" id="angle" placeholder="e.g. 25" step="any" />
    <label class="unknown-option"><input type="checkbox" id="angleUnknown"> Unknown</label>

    <label for="strikes">Lightning Strikes per Minute:</label>
    <input type="number" id="strikes" placeholder="e.g. 50" step="1" />

    <div class="info-block">
      <h3>Geographic Inputs (Optional)</h3>
      <label for="observerLat">Observer Latitude (°):</label>
      <input type="number" id="observerLat" placeholder="e.g. 38.5" step="any" />
      <label class="unknown-option"><input type="checkbox" id="obsLatUnknown"> Unknown</label>

      <label for="observerLon">Observer Longitude (°):</label>
      <input type="number" id="observerLon" placeholder="e.g. -77.0" step="any" />

      <label for="stormLat">Storm Latitude (°):</label>
      <input type="number" id="stormLat" placeholder="e.g. 40.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLatUnknown"> Unknown</label>

      <label for="stormLon">Storm Longitude (°):</label>
      <input type="number" id="stormLon" placeholder="e.g. -80.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLonUnknown"> Unknown</label>

      <label for="elevAngle">Elevation Angle from Observer (°):</label>
      <input type="number" id="elevAngle" placeholder="e.g. 10" step="any" />
      <label class="unknown-option"><input type="checkbox" id="elevAngleUnknown"> Unknown</label>
    </div>

    <div class="two-buttons">
      <button id="calcButton">Calculate</button>
      <button id="pdfButton">Generate PDF</button>
    </div>

    <!-- Results Panel -->
    <div id="resultPanel" class="result" style="display:none;">
      <h3>Storm Results</h3>
      <p>
        <strong>CAPE:</strong> <span id="resCAPE"></span><br>
        <strong>Shear (knots):</strong> <span id="resShear"></span><br>
        <strong>Angle (°):</strong> <span id="resAngle"></span><br>
        <strong>Updraft Speed (w):</strong> <span id="resUpdraft"></span><br>
        <strong>Storm Height (m):</strong> <span id="resHeight"></span><br>
        <strong>Total Shear (knots):</strong> <span id="resTotalShear"></span><br>
        <strong>Rotation Shear (knots):</strong> <span id="resRotShear"></span><br>
      </p>
    </div>

    <div id="infoBlock" class="info-block" style="display:none;">
      <h4>Unified Equation Summary</h4>
      <p>
        We combine geometry (lat/lon + elevation angle) to get storm distance 
        <span class="formula">R</span> and height 
        <span class="formula">H</span>, then compute or invert
        <span class="formula">w = √(2 · CAPE) · D · (1 + γ·(strikes/100))</span>,
        relate updraft <span class="formula">w</span> to shear 
        <span class="formula">U = w·tan(θ)</span>, and if needed
        <span class="formula">CAPE</span> is solved by inverting w. Finally, add rotational shear:
        <span class="formula">U<sub>rot</sub> = 2Ω·sin(lat)·R</span>.
      </p>
    </div>
  </div>

  <!-- 1) Load jsPDF from CDN (no local file needed). -->
  <script 
    src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    integrity="sha512-KO2+IBZ6Hb8OaY0nS8jNktEtmLLn3nsujh1I82D0phWC3UqCPmSL6+8CsH6XSNJIg7BmPoZepw7V6WJCIi3QEw=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer">
  </script>

  <!-- 2) Our main JS code for calculations & PDF generation. -->
  <script>
    /************************************************************
     * Constants & Helper Functions
     ************************************************************/
    const mpsToKnots = 1.94384;
    const dragCoefficient = 0.8;
    const dragScalingConstant = 1e6;
    const seaLevelAirDensity = 1.225;
    const T0 = 288.15;    // K
    const L = 0.0065;     // K/m
    const g = 9.80665;    // m/s^2
    const R_ = 287.058;   // J/(kg·K)
    const Omega = 7.2921e-5; // Earth's rotation rate in rad/s
    const lightningGamma = 0.5;  // effect of lightning on updraft

    function degToRad(deg) {
      return deg * (Math.PI / 180);
    }
    function radToDeg(rad) {
      return rad * (180 / Math.PI);
    }
    function round(value, decimals=2) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    // Basic Haversine
    function haversine(lat1, lon1, lat2, lon2) {
      const R_earth = 6371000; // meters
      let dLat = degToRad(lat2 - lat1);
      let dLon = degToRad(lon2 - lon1);
      let a = Math.sin(dLat/2) ** 2 +
              Math.cos(degToRad(lat1)) * Math.cos(degToRad(lat2)) * 
              Math.sin(dLon/2) ** 2;
      let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R_earth * c;
    }

    // Calculate air density at given height
    function airDensity(height) {
      const T = T0 - L * height;
      if (T <= 0) return 0;
      const exponent = (g / (R_ * L)) - 1;
      return seaLevelAirDensity * Math.pow((T / T0), exponent);
    }

    // Default storm height if geometry not used
    function defaultStormHeight(cape) {
      return 4000 + 2*Math.sqrt(cape);
    }

    // Effective updraft from CAPE + lightning + drag
    function effectiveUpdraft(cape, strikes, stormHeight) {
      let wIdeal = Math.sqrt(2 * cape);
      let rho = airDensity(stormHeight);
      let dragFactor = 1 - (dragCoefficient * rho * stormHeight / dragScalingConstant);
      dragFactor = Math.max(0, dragFactor);
      let lightningFactor = 1 + lightningGamma*(strikes / 100);
      return wIdeal * dragFactor * lightningFactor;
    }

    // Main calculation triggered by "Calculate"
    document.getElementById("calcButton").addEventListener("click", () => {
      // 1) Gather user inputs
      let capeStr = document.getElementById("cape").value.trim();
      let shearStr = document.getElementById("shear").value.trim();
      let angleStr = document.getElementById("angle").value.trim();
      let strikesStr = document.getElementById("strikes").value.trim();

      let capeUnknown = document.getElementById("capeUnknown").checked;
      let shearUnknown = document.getElementById("shearUnknown").checked;
      let angleUnknown = document.getElementById("angleUnknown").checked;

      let providedCAPE = (!capeUnknown && capeStr !== "") ? parseFloat(capeStr) : undefined;
      let providedShear = (!shearUnknown && shearStr !== "") ? parseFloat(shearStr) : undefined;
      let providedAngle = (!angleUnknown && angleStr !== "") ? parseFloat(angleStr) : undefined;

      // Must have exactly 2 known among CAPE, Shear, Angle
      let knownCount = [providedCAPE, providedShear, providedAngle].filter(v => v!==undefined).length;
      if (knownCount !== 2) {
        alert("Please provide exactly two of: CAPE, Shear, Angle (and mark the other as Unknown).");
        return;
      }

      let strikes = (strikesStr !== "") ? parseFloat(strikesStr) : 0;
      if (strikes < 0) strikes = 0;

      // 2) Geographic
      let obsLatStr = document.getElementById("observerLat").value.trim();
      let obsLatUnknown = document.getElementById("obsLatUnknown").checked;
      let obsLonStr = document.getElementById("observerLon").value.trim();

      let stormLatStr = document.getElementById("stormLat").value.trim();
      let stormLatUnknown = document.getElementById("stormLatUnknown").checked;
      let stormLonStr = document.getElementById("stormLon").value.trim();
      let stormLonUnknown = document.getElementById("stormLonUnknown").checked;

      let elevAngleStr = document.getElementById("elevAngle").value.trim();
      let elevAngleUnknown = document.getElementById("elevAngleUnknown").checked;

      let distance = undefined;
      // If we have observer lat/lon & storm lat/lon, compute distance
      if (!obsLatUnknown && !stormLatUnknown && obsLatStr && stormLatStr) {
        let obsLat = parseFloat(obsLatStr);
        let obsLon = (obsLonStr) ? parseFloat(obsLonStr) : 0;
        let sLat = parseFloat(stormLatStr);
        let sLon = (stormLonStr) ? parseFloat(stormLonStr) : 0;
        distance = haversine(obsLat, obsLon, sLat, sLon);
      }

      // 3) Storm Height
      let finalStormHeight = 4000; // fallback
      let geoHeightUsed = false;
      if (!elevAngleUnknown && elevAngleStr && distance !== undefined) {
        let elevAngle = parseFloat(elevAngleStr);
        finalStormHeight = distance * Math.tan(degToRad(elevAngle));
        geoHeightUsed = true;
      } else if (providedCAPE !== undefined) {
        finalStormHeight = defaultStormHeight(providedCAPE);
      }

      // 4) Solve for the missing param
      let computedCAPE = providedCAPE;
      let computedAngle = providedAngle;
      let computedShearKnots = providedShear; // user gave it in knots

      // (a) Missing Angle
      if (computedAngle === undefined) {
        if (!computedCAPE) {
          alert("Cannot compute angle without a CAPE value.");
          return;
        }
        let wEff = effectiveUpdraft(computedCAPE, strikes, finalStormHeight);
        let shearMs = computedShearKnots / mpsToKnots;
        computedAngle = radToDeg(Math.atan(shearMs / wEff));
      }
      // (b) Missing Shear
      else if (computedShearKnots === undefined) {
        if (!computedCAPE) {
          alert("Cannot compute shear without a CAPE value.");
          return;
        }
        let wEff = effectiveUpdraft(computedCAPE, strikes, finalStormHeight);
        let angleRad = degToRad(computedAngle);
        let shearMs = wEff * Math.tan(angleRad);
        computedShearKnots = shearMs * mpsToKnots;
      }
      // (c) Missing CAPE
      else if (computedCAPE === undefined) {
        let angleRad = degToRad(computedAngle);
        let shearMs = computedShearKnots / mpsToKnots;

        // w_basic = shearMs / tan(angle)
        // w_basic = sqrt(2*CAPE)*D*(1 + gamma*(strikes/100))
        // => CAPE = ...
        let Hguess = geoHeightUsed ? finalStormHeight : 4000;

        let rho = airDensity(Hguess);
        let dragFactor = Math.max(0, 1 - (dragCoefficient*rho*Hguess/dragScalingConstant));
        let lightningFactor = 1 + lightningGamma*(strikes/100);

        let wBasic = shearMs / Math.tan(angleRad);
        let sqrtTerm = wBasic / (dragFactor*lightningFactor);
        computedCAPE = (Math.pow(sqrtTerm, 2))/2;

        if (!geoHeightUsed) {
          finalStormHeight = defaultStormHeight(computedCAPE);
        }
      }

      // 5) Final Updraft
      let finalUpdraft = effectiveUpdraft(computedCAPE, strikes, finalStormHeight);

      // 6) Basic Shear from w & angle
      let angleRadFinal = degToRad(computedAngle);
      let basicShearMs = finalUpdraft * Math.tan(angleRadFinal);
      let basicShearKnots = basicShearMs * mpsToKnots; // in knots

      // if user provided shear, we rely on that, else use basicShearKnots
      let finalShearKnots = (providedShear !== undefined) ? providedShear : basicShearKnots;

      // 7) Rotational Shear (if we have lat & distance)
      let rotShearKnots = 0;
      if (distance !== undefined && obsLatStr && !obsLatUnknown) {
        let latVal = parseFloat(obsLatStr);
        let fVal = 2*Omega*Math.sin(degToRad(latVal));
        let rotMs = fVal*distance; // simplistic approach
        rotShearKnots = rotMs*mpsToKnots;
      }
      let totalShearKnots = finalShearKnots + rotShearKnots;

      // 8) Display results
      document.getElementById("resCAPE").textContent        = round(computedCAPE,2) + " J/kg";
      document.getElementById("resShear").textContent       = round(finalShearKnots,2);
      document.getElementById("resAngle").textContent       = round(computedAngle,2) + "°";
      document.getElementById("resUpdraft").textContent     = round(finalUpdraft,2) + " m/s (" + round(finalUpdraft*mpsToKnots,2) + " kt)";
      document.getElementById("resHeight").textContent      = round(finalStormHeight,2) + (geoHeightUsed ? " (geo)" : " (default)");
      document.getElementById("resTotalShear").textContent  = round(totalShearKnots,2);
      document.getElementById("resRotShear").textContent    = round(rotShearKnots,2);

      document.getElementById("resultPanel").style.display  = "block";
      document.getElementById("infoBlock").style.display    = "block";
    });

    //  Generate PDF button
    document.getElementById("pdfButton").addEventListener("click", () => {
      // 1) Build a date-based name for the PDF
      const now = new Date();
      const year  = now.getUTCFullYear();
      const month = String(now.getUTCMonth() + 1).padStart(2, '0');
      const day   = String(now.getUTCDate()).padStart(2, '0');
      const hours = String(now.getUTCHours()).padStart(2, '0');
      const mins  = String(now.getUTCMinutes()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}_${hours}${mins}Z`;

      // Optionally, incorporate observer lat/lon if available
      const obsLatStr = document.getElementById("observerLat").value.trim() || "UnknownLat";
      const obsLonStr = document.getElementById("observerLon").value.trim() || "UnknownLon";

      // Construct the final filename, e.g. Storm_2025-01-23_1530Z_Lat35.2_Lon-80.0.pdf
      const fileName = `Storm_${dateStr}_Lat${obsLatStr}_Lon${obsLonStr}.pdf`;

      // 2) Gather text from results
      let capeVal   = document.getElementById("resCAPE").textContent || "(no data)";
      let shearVal  = document.getElementById("resShear").textContent || "(no data)";
      let angleVal  = document.getElementById("resAngle").textContent || "(no data)";
      let updraftVal= document.getElementById("resUpdraft").textContent || "(no data)";
      let heightVal = document.getElementById("resHeight").textContent || "(no data)";
      let totalShr  = document.getElementById("resTotalShear").textContent || "(no data)";
      let rotShr    = document.getElementById("resRotShear").textContent || "(no data)";

      // 3) Create the jsPDF object
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();

      // 4) Write some text
      doc.setFontSize(14);
      doc.text("Storm Survey Results", 10, 10);

      doc.setFontSize(12);
      doc.text(`CAPE: ${capeVal}`, 10, 20);
      doc.text(`Shear (knots): ${shearVal}`, 10, 30);
      doc.text(`Angle (°): ${angleVal}`, 10, 40);
      doc.text(`Updraft: ${updraftVal}`, 10, 50);
      doc.text(`Storm Height: ${heightVal}`, 10, 60);
      doc.text(`Total Shear (knots): ${totalShr}`, 10, 70);
      doc.text(`Rotational Shear (knots): ${rotShr}`, 10, 80);

      // Add short summary of the main equations
      doc.setFontSize(11);
      let eqLines = [
        "Unified Equations:",
        "1) Distance = Haversine(obsLat, obsLon, stormLat, stormLon)",
        "2) Height = Distance * tan(elevAngle) or default(4000 + 2*sqrt(CAPE))",
        "3) w = sqrt(2*CAPE)*DragFactor*(1 + 0.5*(strikes/100))",
        "4) Shear = w * tan(angle)",
        "5) RotShear = 2*Omega*sin(lat)*Distance",
        "6) Total Shear = Basic Shear + RotShear"
      ];
      let yPos = 95;
      eqLines.forEach(line => {
        doc.text(line, 10, yPos);
        yPos += 7;
      });

      // 5) Download the PDF with the custom date-based filename
      doc.save(fileName);
    });
  </script>
</body>
</html>
