<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Storm Calculator: Reworked Maths</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 2rem;
      background-color: #f0f8ff;
      line-height: 1.6;
    }
    .container {
      background: #fff;
      padding: 2rem;
      border-radius: 10px;
      max-width: 800px;
      margin: auto;
      box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
    }
    h1, h2, h3 {
      text-align: center;
      color: #333;
    }
    label {
      display: block;
      margin-top: 1.2rem;
      color: #333;
    }
    input[type="number"] {
      width: 100%;
      padding: 0.5rem;
      margin-top: 0.3rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
    }
    .unknown-option {
      font-size: 0.9rem;
      margin-top: 0.3rem;
    }
    button {
      display: block;
      width: 100%;
      padding: 0.8rem;
      background: #007acc;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 1.5rem;
      transition: background 0.3s;
    }
    button:hover {
      background: #005fa3;
    }
    .result {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #e9f5ff;
      border: 1px solid #b3d7ff;
      border-radius: 8px;
    }
    .formula {
      background: #eef;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      display: inline-block;
      margin: 0.2rem 0;
    }
    .info, .geo-info {
      background: #fff8dc;
      padding: 1rem;
      border: 1px solid #f4e1a1;
      border-radius: 8px;
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Storm Calculator</h1>
    <h2>Reworked Meteorological Maths</h2>
    <div class="info">
      <p><strong>Instructions:</strong> Enter <em>exactly two</em> of the three primary inputs below (CAPE, Bulk Wind Shear in knots, and Storm Tilt Angle in degrees). Optionally, enter lightning strikes per minute (which modulate the updraft). For any parameter you don’t know, check its “Unknown” box. This calculator computes the missing parameter plus the effective updraft speed (modified by lighting) and the total shear (incorporating a rotation term from geolocation data).<br><br>
      Key formulas used:
      </p>
      <p class="formula">
        w = (√(2 × CAPE)) × D × Lₓ
      </p>
      <p>
        where D = 1 - (dragCoefficient × airDensity × stormHeight/dragScalingConstant)  
        and Lₓ = 1 + (γ × (lightning strikes/100))
      </p>
      <p class="formula">
        Uₑff = w × tan(θ)
      </p>
      <p>
        (If geolocation data are available, the rotational correction S₍rot₎ = f × d is added, where f = 2Ω sin(observerLat) and d is the horizontal distance.)
      </p>
    </div>

    <!-- Primary Inputs -->
    <label for="cape">CAPE (J/kg):</label>
    <input type="number" id="cape" placeholder="e.g. 2000" step="any" />
    <label class="unknown-option"><input type="checkbox" id="capeUnknown"> Unknown</label>

    <label for="shear">Bulk Wind Shear (knots):</label>
    <input type="number" id="shear" placeholder="e.g. 30" step="any" />
    <label class="unknown-option"><input type="checkbox" id="shearUnknown"> Unknown</label>

    <label for="angle">Storm Tilt Angle (θ in degrees):</label>
    <input type="number" id="angle" placeholder="e.g. 25" step="any" />
    <label class="unknown-option"><input type="checkbox" id="angleUnknown"> Unknown</label>

    <label for="strikes">Lightning Strikes per Minute:</label>
    <input type="number" id="strikes" placeholder="e.g. 50" step="1" />

    <!-- Optional Geographic Data -->
    <div class="geo-info">
      <h3>Geographic Data (Optional)</h3>
      <label for="stormLat">Storm Latitude (°):</label>
      <input type="number" id="stormLat" placeholder="e.g. 40.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLatUnknown"> Unknown</label>

      <label for="stormLon">Storm Longitude (°):</label>
      <input type="number" id="stormLon" placeholder="e.g. -80.0" step="any" />
      <label class="unknown-option"><input type="checkbox" id="stormLonUnknown"> Unknown</label>

      <label for="observerLat">Observer Latitude (°):</label>
      <input type="number" id="observerLat" placeholder="e.g. 38.5" step="any" />
      <label class="unknown-option"><input type="checkbox" id="observerLatUnknown"> Unknown</label>

      <label for="observerLon">Observer Longitude (°):</label>
      <input type="number" id="observerLon" placeholder="e.g. -77.0" step="any" />

      <label for="elevAngle">Elevation Angle from Observer (°):</label>
      <input type="number" id="elevAngle" placeholder="e.g. 10" step="any" />
      <label class="unknown-option"><input type="checkbox" id="elevAngleUnknown"> Unknown</label>
    </div>

    <button id="calcButton">Calculate</button>

    <!-- Results -->
    <div id="result" class="result" style="display:none;">
      <h3>Results</h3>
      <p>
        <strong>CAPE:</strong> <span id="capeVal"></span> J/kg<br>
        <strong>Shear (basic or computed):</strong> <span id="shearVal"></span> knots<br>
        <strong>Angle (θ):</strong> <span id="angleVal"></span> °<br>
        <strong>Effective Updraft Speed (w):</strong> <span id="updraft_mps"></span> m/s<br>
        <strong>Total Effective Shear:</strong> <span id="totalShear"></span> knots<br>
        <strong>Storm Height:</strong> <span id="heightVal"></span> m<br>
        <strong>Rotational Shear Contribution:</strong> <span id="rotationShear"></span>
      </p>
      <p id="explanation"></p>
    </div>
  </div>

  <script>
    /************************************************************
     * Constants & Helper Functions
     ************************************************************/
    const mpsToKnots = 1.94384;
    const mpsToKmph = 3.6;
    const dragCoefficient = 0.8;
    const dragScalingConstant = 1e6;
    const seaLevelAirDensity = 1.225;
    const T0 = 288.15;
    const L = 0.0065;
    const g = 9.80665;
    const R = 287.058;
    const Omega = 7.2921e-5; // Earth's rotation rate in rad/s

    // For lightning scaling (γ parameter)
    const lightningGamma = 0.5; // Adjust sensitivity of lightning effect

    function degToRad(deg) {
      return deg * (Math.PI / 180);
    }
    function radToDeg(rad) {
      return rad * (180 / Math.PI);
    }
    function round(value, decimals) {
      return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
    }

    // Compute air density at a given height (in meters)
    function calculateAirDensity(height) {
      const T = T0 - L * height;
      if (T <= 0) return 0;
      const exponent = (g / (R * L)) - 1;
      return seaLevelAirDensity * Math.pow((T / T0), exponent);
    }

    // Default storm height using CAPE (if geo not provided)
    function defaultStormHeight(cape) {
      return 4000 + 2 * Math.sqrt(cape);
    }

    // Compute horizontal distance (in meters) using the Haversine formula
    function haversine(lat1, lon1, lat2, lon2) {
      const R_earth = 6371000; // radius in meters
      let dLat = degToRad(lat2 - lat1);
      let dLon = degToRad(lon2 - lon1);
      let a = Math.sin(dLat/2) ** 2 +
              Math.cos(degToRad(lat1)) * Math.cos(degToRad(lat2)) *
              Math.sin(dLon/2) ** 2;
      let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R_earth * c;
    }

    // Compute effective updraft speed using CAPE, lightning strikes and drag factor.
    function computeEffectiveUpdraft(cape, strikes, stormHeight) {
      let wIdeal = Math.sqrt(2 * cape);
      // Compute local air density based on provided stormHeight.
      let airDensity = calculateAirDensity(stormHeight);
      let dragFactor = 1 - (dragCoefficient * airDensity * stormHeight / dragScalingConstant);
      dragFactor = Math.max(0, dragFactor);
      // Lightning factor (L_f = 1 + γ*(strikes/100))
      let lightningFactor = 1 + lightningGamma * (strikes / 100);
      let wEff = wIdeal * dragFactor * lightningFactor;
      return { wEff, dragFactor };
    }

    /************************************************************
     * Main Calculation Logic
     ************************************************************/
    document.getElementById("calcButton").addEventListener("click", function () {
      // Gather primary input values
      let capeStr = document.getElementById("cape").value.trim();
      let shearStr = document.getElementById("shear").value.trim();
      let angleStr = document.getElementById("angle").value.trim();
      let strikesStr = document.getElementById("strikes").value.trim();

      // Unknown checkboxes for primary inputs
      let capeUnknown = document.getElementById("capeUnknown").checked;
      let shearUnknown = document.getElementById("shearUnknown").checked;
      let angleUnknown = document.getElementById("angleUnknown").checked;

      let providedCAPE = (!capeUnknown && capeStr !== "") ? parseFloat(capeStr) : undefined;
      let providedShear = (!shearUnknown && shearStr !== "") ? parseFloat(shearStr) : undefined;
      let providedAngle = (!angleUnknown && angleStr !== "") ? parseFloat(angleStr) : undefined;

      // Exactly two of these primary parameters must be provided.
      let count = 0;
      if (providedCAPE !== undefined) count++;
      if (providedShear !== undefined) count++;
      if (providedAngle !== undefined) count++;

      if (count !== 2) {
        alert("Please ensure that exactly two of the three inputs (CAPE, Shear, and Angle) are known.");
        return;
      }

      // Parse lightning strikes per minute (default to 50 if not provided).
      let strikes = strikesStr !== "" ? parseInt(strikesStr) : 50;
      if (strikes < 0) {
        alert("Lightning strikes per minute must be non-negative.");
        return;
      }

      // --- Optional Geographic Data ---
      let geoHeightComputed = false;
      let stormLatStr = document.getElementById("stormLat").value.trim();
      let stormLonStr = document.getElementById("stormLon").value.trim();
      let observerLatStr = document.getElementById("observerLat").value.trim();
      let observerLonStr = document.getElementById("observerLon").value.trim();
      let elevAngleStr = document.getElementById("elevAngle").value.trim();

      let stormLatUnknown = document.getElementById("stormLatUnknown").checked;
      let stormLonUnknown = document.getElementById("stormLonUnknown").checked;
      let observerLatUnknown = document.getElementById("observerLatUnknown").checked;
      let elevAngleUnknown = document.getElementById("elevAngleUnknown").checked;

      // Determine horizontal distance (d) if geolocation is available.
      let horizontalDistance = undefined;
      if (!stormLatUnknown && !stormLonUnknown && !observerLatUnknown &&
          stormLatStr !== "" && stormLonStr !== "" && observerLatStr !== "") {
        let stormLat = parseFloat(stormLatStr);
        let stormLon = parseFloat(stormLonStr);
        let observerLat = parseFloat(observerLatStr);
        let observerLon = observerLonStr !== "" ? parseFloat(observerLonStr) : 0;
        horizontalDistance = haversine(observerLat, observerLon, stormLat, stormLon);
      }

      // Storm Height: use geolocation + elevation angle if available.
      let finalStormHeight;
      if (!elevAngleUnknown && elevAngleStr !== "" && horizontalDistance !== undefined) {
        let elevAngle = parseFloat(elevAngleStr);
        finalStormHeight = horizontalDistance * Math.tan(degToRad(elevAngle));
        geoHeightComputed = true;
      } else if (providedCAPE !== undefined) {
        finalStormHeight = defaultStormHeight(providedCAPE);
      } else {
        finalStormHeight = 4000; // fallback default
      }

      // --- Solve for the missing parameter ---
      // We have the relation: U_basic = w × tan(θ)  and w is computed from CAPE.
      // The lightning factor is built into the updraft.
      let computedCAPE = providedCAPE;
      let computedShear = providedShear;
      let computedAngle = providedAngle; // in degrees
      
      // Case 1: Missing Angle  
      if (providedAngle === undefined) {
        if (providedCAPE === undefined) {
          alert("Cannot compute angle without CAPE value for updraft calculation.");
          return;
        }
        let { wEff } = computeEffectiveUpdraft(providedCAPE, strikes, finalStormHeight);
        if (!wEff) {
          alert("Effective updraft speed is zero, cannot solve for angle.");
          return;
        }
        // Provided shear (in knots) needs to be converted to m/s.
        let shear_ms = providedShear / mpsToKnots;
        computedAngle = radToDeg(Math.atan(shear_ms / wEff));
      }
      // Case 2: Missing Shear  
      else if (providedShear === undefined) {
        if (providedCAPE === undefined) {
          alert("Cannot compute shear without CAPE value for updraft calculation.");
          return;
        }
        let { wEff } = computeEffectiveUpdraft(providedCAPE, strikes, finalStormHeight);
        let angleRad = degToRad(providedAngle);
        let shear_ms = wEff * Math.tan(angleRad);
        computedShear = shear_ms * mpsToKnots;
      }
      // Case 3: Missing CAPE  
      else if (providedCAPE === undefined) {
        // We need to invert the updraft equation.
        // Given: U_basic = w * tan(θ) and w = √(2*CAPE)*D*L_f,
        // Rearranging: √(2*CAPE) = w / (D * L_f)   and w = U_basic / tan(θ)
        // So, CAPE = ( (U_basic / tan(θ)) / (D * L_f) )^2 / 2.
        // We use default storm height since CAPE is unknown.
        let defaultHeight = 4000;
        let airDensityDefault = calculateAirDensity(defaultHeight);
        let dragFactorDefault = 1 - (dragCoefficient * airDensityDefault * defaultHeight / dragScalingConstant);
        dragFactorDefault = Math.max(0, dragFactorDefault);
        // Lightning factor from strikes.
        let lightningFactor = 1 + lightningGamma * (strikes / 100);
        let angleRad = degToRad(providedAngle);
        let shear_ms = providedShear / mpsToKnots;
        let wBasic = shear_ms / Math.tan(angleRad);
        let sqrtTerm = wBasic / (dragFactorDefault * lightningFactor);
        computedCAPE = Math.pow(sqrtTerm, 2) / 2;
      }

      // Now, with a CAPE value we can compute the effective updraft.
      let finalUpdraft, basicUpdraft;
      if (computedCAPE !== undefined) {
        let updraftData = computeEffectiveUpdraft(computedCAPE, strikes, finalStormHeight);
        finalUpdraft = updraftData.wEff;
        basicUpdraft = Math.sqrt(2 * computedCAPE);
      } else {
        finalUpdraft = undefined;
      }

      // Compute basic effective shear (from the tilt angle)
      let basicShear_ms = (finalUpdraft !== undefined && computedAngle !== undefined) ? finalUpdraft * Math.tan(degToRad(computedAngle)) : 0;
      let basicShear_knots = basicShear_ms * mpsToKnots;

      // Geolocation correction: if horizontal distance and observer latitude are provided, add a rotation term.
      let rotationalShear_ms = 0;
      if (horizontalDistance !== undefined && !observerLatUnknown && observerLatStr !== "") {
        let observerLat = parseFloat(observerLatStr);
        let f = 2 * Omega * Math.sin(degToRad(observerLat));
        // Here, we take the product f*d gives a m/s term.
        rotationalShear_ms = f * horizontalDistance;
      }
      let rotationalShear_knots = rotationalShear_ms * mpsToKnots;
      let totalShear_knots = basicShear_knots + rotationalShear_knots;

      // Display results.
      if (computedCAPE !== undefined)
        document.getElementById("capeVal").textContent = round(computedCAPE, 2);
      else
        document.getElementById("capeVal").textContent = "Not provided (computed)";
      
      if (computedShear !== undefined)
        document.getElementById("shearVal").textContent = round(computedShear, 2);
      else
        document.getElementById("shearVal").textContent = "Not provided (computed)";
      
      if (computedAngle !== undefined)
        document.getElementById("angleVal").textContent = round(computedAngle, 2);
      else
        document.getElementById("angleVal").textContent = "Not provided (computed)";
      
      if (finalUpdraft !== undefined) {
        document.getElementById("updraft_mps").textContent = round(finalUpdraft, 2) + " m/s (" + round(finalUpdraft * mpsToKnots, 2) + " knots)";
      } else {
        document.getElementById("updraft_mps").textContent = "N/A";
      }
      
      document.getElementById("totalShear").textContent = round(totalShear_knots, 2);
      document.getElementById("heightVal").textContent = round(finalStormHeight, 2) + (geoHeightComputed ? " (geo trig.)" : "");
      
      if (rotationalShear_knots !== 0)
        document.getElementById("rotationShear").textContent = round(rotationalShear_knots, 2) + " knots (rotational)";
      else
        document.getElementById("rotationShear").textContent = "Not computed (insufficient geo data)";
      
      let explanationText = "Reworked equations:<br>" +
        "<span class='formula'>w = √(2×CAPE) × D × (1 + " + lightningGamma + " × (strikes/100))</span><br>" +
        "with<br>D = 1 - (dragCoefficient×airDensity×stormHeight/dragScalingConstant)<br><br>" +
        "and<br>" +
        "<span class='formula'>Uₑff = w × tan(θ)</span><br>" +
        "Total effective shear = Uₑff + (2Ω sin(observerLat) × horizontalDistance).<br>" +
        "Storm height is determined by geolocation if an elevation angle is provided, otherwise using CAPE.";
      
      document.getElementById("explanation").innerHTML = explanationText;
      document.getElementById("result").style.display = "block";
    });
  </script>
</body>
</html>
